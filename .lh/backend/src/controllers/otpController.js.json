{
    "sourceFile": "backend/src/controllers/otpController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752836234244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752836234244,
            "name": "Commit-0",
            "content": "const OTP = require('../models/OTP');\r\nconst User = require('../models/User'); // ‚úÖ ADD THIS\r\nconst { encryptData, decryptData } = require('../utils/cryptoUtil');\r\n\r\nconst generateOTP = () => {\r\n  return Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP\r\n};\r\n\r\nexports.sendOtp = async (req, res) => {\r\n  try {\r\n    // Decrypt the incoming data\r\n    let decryptedData;\r\n    if (req.body.encryptedData) {\r\n      console.log('üîì Decrypting OTP send data...');\r\n      decryptedData = decryptData(req.body.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = req.body;\r\n    }\r\n\r\n    const { phone, purpose } = decryptedData;\r\n    console.log('üì≤ OTP send request for phone:', phone, 'purpose:', purpose);\r\n\r\n    if (!phone || !purpose) {\r\n      return res.status(400).json({ success: false, error: 'Phone and purpose are required' });\r\n    }\r\n\r\n    try {\r\n      // ‚úÖ Check if user already exists when purpose is \"signup\"\r\n      if (purpose === 'signup') {\r\n        const existingUser = await User.findOne({ phone });\r\n        if (existingUser) {\r\n          return res.status(409).json({ success: false, error: 'User already exists' });\r\n        }\r\n      }\r\n\r\n      const otp = generateOTP();\r\n      console.log(`üì≤ Generating OTP for ${phone} with purpose: ${purpose}`);\r\n\r\n      await OTP.create({ phone, otp, purpose });\r\n\r\n      console.log(`üì≤ OTP for ${phone}: ${otp}`);\r\n\r\n      return res.status(200).json({ success: true, message: 'OTP sent successfully' });\r\n    } catch (error) {\r\n      console.error('‚ùå Error sending OTP:', error.message);\r\n      return res.status(500).json({ success: false, error: 'Failed to send OTP' });\r\n    }\r\n  } catch (decryptionError) {\r\n    console.error('OTP send decryption error:', decryptionError);\r\n    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n  }\r\n};\r\n\r\nexports.verifyOtp = async (req, res) => {\r\n  try {\r\n    console.log('üîç Verifying OTP...');\r\n    \r\n    // Decrypt the incoming data\r\n    let decryptedData;\r\n    if (req.body.encryptedData) {\r\n      console.log('üîì Decrypting OTP verification data...');\r\n      decryptedData = decryptData(req.body.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = req.body;\r\n    }\r\n\r\n    const { phone, otp, purpose } = decryptedData;\r\n    console.log('‚úÖ OTP verification for phone:', phone, 'purpose:', purpose);\r\n\r\n    if (!phone || !otp || !purpose) {\r\n      return res.status(400).json({ success: false, error: 'Phone, OTP, and purpose are required' });\r\n    }\r\n\r\n    try {\r\n      const existingOtp = await OTP.findOne({ phone, otp, purpose });\r\n\r\n      if (!existingOtp) {\r\n        return res.status(400).json({ success: false, error: 'Invalid or expired OTP' });\r\n      }\r\n\r\n      console.log(`‚úÖ OTP verified for ${phone} with purpose: ${purpose}`);\r\n\r\n      // ‚úÖ Just verify, don't create user\r\n      await OTP.deleteMany({ phone, purpose }); // optional: cleanup OTPs\r\n\r\n      return res.status(200).json({ success: true, message: 'OTP verified successfully' });\r\n    } catch (error) {\r\n      console.error('‚ùå Error verifying OTP:', error.message);\r\n      return res.status(500).json({ success: false, error: 'Failed to verify OTP' });\r\n    }\r\n  } catch (decryptionError) {\r\n    console.error('OTP verification decryption error:', decryptionError);\r\n    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n  }\r\n};\r\n\r\n"
        }
    ]
}