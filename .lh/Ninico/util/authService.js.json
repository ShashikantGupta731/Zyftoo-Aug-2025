{
    "sourceFile": "Ninico/util/authService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1753614088169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753634367351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,243 @@\n+/**\r\n+ * Authentication Service\r\n+ * Provides authentication-specific API methods using the generic API service\r\n+ */\r\n+\r\n+import { get, post } from './apiService.js';\r\n+import { AUTH, OTP } from './apiEndpoints.js';\r\n+\r\n+/**\r\n+ * Authentication Service Class\r\n+ */\r\n+class AuthService {\r\n+  \r\n+  /**\r\n+   * Check if user exists by phone number\r\n+   * @param {string} phone - Phone number to check\r\n+   * @returns {Promise<Object>} - User existence result\r\n+   */\r\n+  async checkUserByPhone(phone) {\r\n+    try {\r\n+      const response = await get(`${AUTH.CHECK_USER}/${phone}`);\r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Check user by phone error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Check if user exists by email (for corporate flow)\r\n+   * @param {string} email - Email to check\r\n+   * @returns {Promise<Object>} - User existence result with userType\r\n+   */\r\n+  async checkUserByEmail(email) {\r\n+    try {\r\n+      const response = await get(`${AUTH.CHECK_USER_EMAIL}/${encodeURIComponent(email)}`);\r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Check user by email error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * User login\r\n+   * @param {Object} credentials - Login credentials\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - Login result\r\n+   */\r\n+  async login(credentials, encrypt = true) {\r\n+    try {\r\n+      const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n+      \r\n+      // Store auth token if login successful\r\n+      if (response.success && response.data?.data?.token) {\r\n+        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n+        storage.setItem('authToken', response.data.data.token);\r\n+        storage.setItem('user', JSON.stringify(response.data.data.user));\r\n+      }\r\n+      \r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Login error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * User signup/registration\r\n+   * @param {Object} userData - User registration data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - Registration result\r\n+   */\r\n+  async signup(userData, encrypt = true) {\r\n+    try {\r\n+      const controller = new AbortController();\r\n+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\r\n+      \r\n+      const response = await post(AUTH.SIGNUP, userData, encrypt, { signal: controller.signal });\r\n+      clearTimeout(timeoutId);\r\n+      \r\n+      if (response.data?.success) {\r\n+        return {\r\n+          success: true,\r\n+          message: response.data.message,\r\n+          data: response.data\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: response.data?.message || 'Registration failed'\r\n+      };\r\n+    } catch (error) {\r\n+      console.error('Signup error:', error);\r\n+      \r\n+      if (error.name === 'AbortError') {\r\n+        return {\r\n+          success: false,\r\n+          message: 'Request timeout. Please check your connection and try again.'\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: error.response?.data?.message || error.message || 'Registration failed'\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Password reset\r\n+   * @param {Object} resetData - Password reset data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - Reset result\r\n+   */\r\n+  async resetPassword(resetData, encrypt = true) {\r\n+    try {\r\n+      const response = await post(AUTH.RESET_PASSWORD, resetData, encrypt);\r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Reset password error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Send OTP\r\n+   * @param {Object} otpData - OTP request data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - OTP send result\r\n+   */\r\n+  async sendOTP(otpData, encrypt = true) {\r\n+    try {\r\n+      const controller = new AbortController();\r\n+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\r\n+      \r\n+      const response = await post(OTP.SEND, otpData, encrypt, { signal: controller.signal });\r\n+      clearTimeout(timeoutId);\r\n+      \r\n+      return {\r\n+        success: true,\r\n+        message: response.data?.message || 'OTP sent successfully'\r\n+      };\r\n+    } catch (error) {\r\n+      console.error('Send OTP error:', error);\r\n+      \r\n+      if (error.name === 'AbortError') {\r\n+        return {\r\n+          success: false,\r\n+          message: 'Request timeout. Please check your connection and try again.'\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: error.response?.data?.message || error.message || 'Failed to send OTP'\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Verify OTP\r\n+   * @param {Object} verifyData - OTP verification data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - OTP verification result\r\n+   */\r\n+  async verifyOTP(verifyData, encrypt = true) {\r\n+    try {\r\n+      const controller = new AbortController();\r\n+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\r\n+      \r\n+      const response = await post(OTP.VERIFY, verifyData, encrypt, { signal: controller.signal });\r\n+      clearTimeout(timeoutId);\r\n+      \r\n+      return {\r\n+        success: true,\r\n+        message: response.data?.message || 'OTP verified successfully'\r\n+      };\r\n+    } catch (error) {\r\n+      console.error('Verify OTP error:', error);\r\n+      \r\n+      if (error.name === 'AbortError') {\r\n+        return {\r\n+          success: false,\r\n+          message: 'Request timeout. Please check your connection and try again.'\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: error.response?.data?.message || error.message || 'Invalid OTP'\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Logout user\r\n+   */\r\n+  logout() {\r\n+    // Clear all auth data from storage\r\n+    localStorage.removeItem('authToken');\r\n+    localStorage.removeItem('user');\r\n+    sessionStorage.removeItem('authToken');\r\n+    sessionStorage.removeItem('user');\r\n+  }\r\n+\r\n+  /**\r\n+   * Get current user from storage\r\n+   * @returns {Object|null} - Current user data\r\n+   */\r\n+  getCurrentUser() {\r\n+    try {\r\n+      const userFromLocal = localStorage.getItem('user');\r\n+      const userFromSession = sessionStorage.getItem('user');\r\n+      const userData = userFromLocal || userFromSession;\r\n+      \r\n+      return userData ? JSON.parse(userData) : null;\r\n+    } catch (error) {\r\n+      console.error('Error getting current user:', error);\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Get current auth token\r\n+   * @returns {string|null} - Current auth token\r\n+   */\r\n+  getAuthToken() {\r\n+    return localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n+  }\r\n+\r\n+  /**\r\n+   * Check if user is authenticated\r\n+   * @returns {boolean} - Authentication status\r\n+   */\r\n+  isAuthenticated() {\r\n+    return !!this.getAuthToken();\r\n+  }\r\n+}\r\n+\r\n+// Export singleton instance\r\n+export default new AuthService();\r\n"
                },
                {
                    "date": 1753634453805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -240,182 +240,4 @@\n }\r\n \r\n // Export singleton instance\r\n export default new AuthService();\r\n-/**\r\n- * Authentication Service\r\n- * Provides authentication-specific API methods using the generic API service\r\n- */\r\n-\r\n-import { get, post } from './apiService.js';\r\n-import { AUTH, OTP } from './apiEndpoints.js';\r\n-\r\n-/**\r\n- * Authentication Service Class\r\n- */\r\n-class AuthService {\r\n-  \r\n-  /**\r\n-   * Check if user exists by phone number\r\n-   * @param {string} phone - Phone number to check\r\n-   * @returns {Promise<Object>} - User existence result\r\n-   */\r\n-  async checkUserByPhone(phone) {\r\n-    try {\r\n-      const response = await get(`${AUTH.CHECK_USER}/${phone}`);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Check user by phone error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Check if user exists by email (for corporate flow)\r\n-   * @param {string} email - Email to check\r\n-   * @returns {Promise<Object>} - User existence result with userType\r\n-   */\r\n-  async checkUserByEmail(email) {\r\n-    try {\r\n-      const response = await get(`${AUTH.CHECK_USER_EMAIL}/${encodeURIComponent(email)}`);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Check user by email error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * User login\r\n-   * @param {Object} credentials - Login credentials\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - Login result\r\n-   */\r\n-  async login(credentials, encrypt = true) {\r\n-    try {\r\n-      const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n-      \r\n-      // Store auth token if login successful\r\n-      if (response.success && response.data?.data?.token) {\r\n-        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n-        storage.setItem('authToken', response.data.data.token);\r\n-        storage.setItem('user', JSON.stringify(response.data.data.user));\r\n-      }\r\n-      \r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Login error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * User signup/registration\r\n-   * @param {Object} userData - User registration data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - Registration result\r\n-   */\r\n-  async signup(userData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(AUTH.SIGNUP, userData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Signup error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Password reset\r\n-   * @param {Object} resetData - Password reset data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - Reset result\r\n-   */\r\n-  async resetPassword(resetData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(AUTH.RESET_PASSWORD, resetData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Reset password error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Send OTP\r\n-   * @param {Object} otpData - OTP request data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - OTP send result\r\n-   */\r\n-  async sendOTP(otpData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(OTP.SEND, otpData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Send OTP error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Verify OTP\r\n-   * @param {Object} verifyData - OTP verification data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - OTP verification result\r\n-   */\r\n-  async verifyOTP(verifyData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(OTP.VERIFY, verifyData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Verify OTP error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Logout user\r\n-   */\r\n-  logout() {\r\n-    // Clear all auth data from storage\r\n-    localStorage.removeItem('authToken');\r\n-    localStorage.removeItem('user');\r\n-    sessionStorage.removeItem('authToken');\r\n-    sessionStorage.removeItem('user');\r\n-  }\r\n-\r\n-  /**\r\n-   * Get current user from storage\r\n-   * @returns {Object|null} - Current user data\r\n-   */\r\n-  getCurrentUser() {\r\n-    try {\r\n-      const userFromLocal = localStorage.getItem('user');\r\n-      const userFromSession = sessionStorage.getItem('user');\r\n-      const userData = userFromLocal || userFromSession;\r\n-      \r\n-      return userData ? JSON.parse(userData) : null;\r\n-    } catch (error) {\r\n-      console.error('Error getting current user:', error);\r\n-      return null;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Get current auth token\r\n-   * @returns {string|null} - Current auth token\r\n-   */\r\n-  getAuthToken() {\r\n-    return localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n-  }\r\n-\r\n-  /**\r\n-   * Check if user is authenticated\r\n-   * @returns {boolean} - Authentication status\r\n-   */\r\n-  isAuthenticated() {\r\n-    return !!this.getAuthToken();\r\n-  }\r\n-}\r\n-\r\n-// Export singleton instance\r\n-export default new AuthService();\r\n"
                }
            ],
            "date": 1753614088169,
            "name": "Commit-0",
            "content": "/**\r\n * Authentication Service\r\n * Provides authentication-specific API methods using the generic API service\r\n */\r\n\r\nimport { get, post } from './apiService.js';\r\nimport { AUTH, OTP } from './apiEndpoints.js';\r\n\r\n/**\r\n * Authentication Service Class\r\n */\r\nclass AuthService {\r\n  \r\n  /**\r\n   * Check if user exists by phone number\r\n   * @param {string} phone - Phone number to check\r\n   * @returns {Promise<Object>} - User existence result\r\n   */\r\n  async checkUserByPhone(phone) {\r\n    try {\r\n      const response = await get(`${AUTH.CHECK_USER}/${phone}`);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check user by phone error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if user exists by email (for corporate flow)\r\n   * @param {string} email - Email to check\r\n   * @returns {Promise<Object>} - User existence result with userType\r\n   */\r\n  async checkUserByEmail(email) {\r\n    try {\r\n      const response = await get(`${AUTH.CHECK_USER_EMAIL}/${encodeURIComponent(email)}`);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check user by email error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * User login\r\n   * @param {Object} credentials - Login credentials\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - Login result\r\n   */\r\n  async login(credentials, encrypt = true) {\r\n    try {\r\n      const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n      \r\n      // Store auth token if login successful\r\n      if (response.success && response.data?.data?.token) {\r\n        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n        storage.setItem('authToken', response.data.data.token);\r\n        storage.setItem('user', JSON.stringify(response.data.data.user));\r\n      }\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Login error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * User signup/registration\r\n   * @param {Object} userData - User registration data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - Registration result\r\n   */\r\n  async signup(userData, encrypt = true) {\r\n    try {\r\n      const response = await post(AUTH.SIGNUP, userData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Signup error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Password reset\r\n   * @param {Object} resetData - Password reset data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - Reset result\r\n   */\r\n  async resetPassword(resetData, encrypt = true) {\r\n    try {\r\n      const response = await post(AUTH.RESET_PASSWORD, resetData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Reset password error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send OTP\r\n   * @param {Object} otpData - OTP request data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - OTP send result\r\n   */\r\n  async sendOTP(otpData, encrypt = true) {\r\n    try {\r\n      const response = await post(OTP.SEND, otpData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Send OTP error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify OTP\r\n   * @param {Object} verifyData - OTP verification data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - OTP verification result\r\n   */\r\n  async verifyOTP(verifyData, encrypt = true) {\r\n    try {\r\n      const response = await post(OTP.VERIFY, verifyData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Verify OTP error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logout user\r\n   */\r\n  logout() {\r\n    // Clear all auth data from storage\r\n    localStorage.removeItem('authToken');\r\n    localStorage.removeItem('user');\r\n    sessionStorage.removeItem('authToken');\r\n    sessionStorage.removeItem('user');\r\n  }\r\n\r\n  /**\r\n   * Get current user from storage\r\n   * @returns {Object|null} - Current user data\r\n   */\r\n  getCurrentUser() {\r\n    try {\r\n      const userFromLocal = localStorage.getItem('user');\r\n      const userFromSession = sessionStorage.getItem('user');\r\n      const userData = userFromLocal || userFromSession;\r\n      \r\n      return userData ? JSON.parse(userData) : null;\r\n    } catch (error) {\r\n      console.error('Error getting current user:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current auth token\r\n   * @returns {string|null} - Current auth token\r\n   */\r\n  getAuthToken() {\r\n    return localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n  }\r\n\r\n  /**\r\n   * Check if user is authenticated\r\n   * @returns {boolean} - Authentication status\r\n   */\r\n  isAuthenticated() {\r\n    return !!this.getAuthToken();\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport default new AuthService();\r\n"
        }
    ]
}